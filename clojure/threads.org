https://markm208.github.io/cljbook/chapter7/01/playback.html?view=code

** This thread prints something to the screen
#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (def a-thread (new Thread (fn [] (println "In a thread"))))
  (.start a-thread)

  (def a-thread (new Thread (fn [] (println "In a thread"))))
  (. a-thread start)
#+END_SRC

#+RESULTS:
#+begin_src clojure
In a thread
In a thread
#+end_src

** Order of execution is not guaranteed by sequentially lining them up
#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (println "Before creating threads") 
 
  (def thread1 (new Thread (fn [] (println "Thread 1")))) 
  (.start thread1) 
 
  (def thread2 (new Thread (fn [] (println "Thread 2")))) 
  (.start thread2) 
 
  (def thread3 (new Thread (fn [] (println "Thread 3")))) 
  (.start thread3) 
 
  (println "After creating threads")
#+END_SRC

#+RESULTS:
#+begin_src clojure
Before creating threads
Thread 1
Thread 2
Thread 3
After creating threads
#+end_src

** main thread
There are actually four threads in this
program. The three I have created explicitly
and the one that I get automatically when I
run a Clojure program (sometimes called the
'main' thread).

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (println "Before creating threads") 
   
  (def thread1 (new Thread (fn [] (println "Thread 1")))) 
  (.start thread1) 
   
  (def thread2 (new Thread (fn [] (println "Thread 2")))) 
  (.start thread2) 
   
  (def thread3 (new Thread (fn [] (println "Thread 3")))) 
  (.start thread3) 
   
  ;; This sleeps the main thread
  (Thread/sleep 500) 
   
  (println "After creating threads")
#+END_SRC

#+RESULTS:
#+begin_src clojure
Before creating threads
Thread 1
Thread 2
Thread 3
After creating threads
#+end_src

** executors
I am importing that class so that I can create
10 threads and have them each do a little work
for me.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (import '(java.util.concurrent Executors)) 
   
  ; (println "Before creating threads") 
   
  ; (def thread1 (new Thread (fn [] (println "Thread 1")))) 
  ; (.start thread1) 
   
  ; (def thread2 (new Thread (fn [] (println "Thread 2")))) 
  ; (.start thread2) 
   
  ; (def thread3 (new Thread (fn [] (println "Thread 3")))) 
  ; (.start thread3) 
   
  ; (Thread/sleep 500) 
   
  ; (println "After creating threads")
#+END_SRC

** future
The functions the threads execute each returns
a value. That value will be stored inside a
'future' object which will hold on to the
function's return value until I am ready to
use it. Then I'll ask each future for the
return value when the thread is done and print
them.