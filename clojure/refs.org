A ref is like a mutable pointer. It can point
to different immutable values over time.
Further, Clojure makes sure that if multiple
threads are accessing the same ref they won't
interfere with each other.g

There is a function called ref-set that allows
a programmer to change what a ref points to. A
ref is mutable but the data it points to is
always immutable.

** transaction
+ transaction :: When two or more refs need to
    be updated in a coordinated operation a
    mechanism is required to make sure that all of
    the ref updates happen or none of them do.
    This is what a transaction does and Clojure
    supports them.

transaction
    Particularly powerful in multi-threaded
    programs where coordinated access to
    multiple global refs is required.

** basic example
#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (def quarters-in-the-bank (ref 4000)) ;$1000 
  (def dollars-in-the-bank (ref 1000)) ;$1000
#+END_SRC

** =deref=
To retrieve a value of a ref there is a
function called deref.

This is short for 'dereference' which is a
term used in programming languages with
explicit pointers.

This says, "go to what the ref points to and
return that value".

The values can be used like other values as
long as you dereference them.

** =dosync=
Whenever two refs need coordination in order
to change together the operations need to be
performed in a transaction.

+ A transaction is a group of operations that are:
- =atomic=
  all ref updates will appear to happen
  simultaneously.
- =consistent=
  all ref updates can be validated for
  correctness and all of them rolled back if
  any one fails.
- =isolated=
  no other part of the program can see
  partially updated refs from other
  transactions.

dosync creates a transaction.