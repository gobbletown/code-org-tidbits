** some
some is a function that iterates over a
collection and passes each value into another
function. 

some will return the first value that the
inner function returns true or nil if none of
them do.

I'll use this to see if any of the sequences
have 5 or more cards in it.

** group by
Then I want to add each sequence to a map
based on the card's suit.

This is exactly what the built in function
group-by does.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (defn get-cards-by-suit [cards] 
      (group-by (fn [card] (card :suit)) cards)) 
#+END_SRC

** some (may as well be called =any?=)

some is a function that iterates over a
collection and passes each value into another
function. 

some will return the first value that the
inner function returns true or nil if none of
them do.

I'll use this to see if _any_ of the sequences
have 5 or more cards in it.

some requires a sequence to iterate over.

** =vals=
The vals function returns a sequence of just
the values in a map.

In this case each of the values is a sequence
of cards with the same suit.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  (defn is-flush? [all-cards-by-suit] 
      (some (fn [cards] (if (>= (count cards) 5))) (vals all-cards-by-suit))) 
#+END_SRC

** =keys=
There is a keys function that returns the keys of a map.

** =contains?=
I turn the ranks into a set so that I can
easily check to see if a rank is in there with
=contains?=.

** every?
Returns true if (pred x) is logical true for
every x in coll, else false.