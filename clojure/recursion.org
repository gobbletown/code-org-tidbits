Tail recursion can be be made more safe and
efficient than regular recursion. In Clojure
the =recur= form is used to make a tail
recursive call.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  ; (defn infinitely-recursive [iteration-number]
  ;     (println "Iteration number:" iteration-number)
  ;     (infinitely-recursive (inc iteration-number)))

  ; (infinitely-recursive 1)

  (defn fib-helper [all-fibs left right number]
      (if (>= left  number)
          all-fibs
  ;        (fib-helper (conj all-fibs left) right (+ left right) number)))
          (recur (conj all-fibs left) right (+ left right) number)))

  (defn fibs-up-to-number [number]
      (fib-helper [] 0 1 number))

  (println (fibs-up-to-number 5))
  (println (fibs-up-to-number 50))
  (println (fibs-up-to-number 500))
#+END_SRC

The previous version uses plain old recursion
which uses a stack frame for each recursive
call.

There is a risk that if the user asks for a
big enough fib number that this function could
blow the stack.

Clojure supports 'tail recursion' with the
recur form.

Tail recursion is possible when there is
nothing done after the recursive call in a
function. In other words, nothing happens on
the way back through the call stack when the
recursion is complete.

In this case there is no work done after the
recursive call so this is a candidate for tail
recursion.