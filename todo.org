* Follow these instructions
https://web.archive.org/web/20190729164342/https://dzone.com/articles/deploy-a-clojure-web-application-to-aws-using-terr

* Copy this across before continuing. It uses =hc=.
$SCRIPTS/aws
$SCRIPTS/saws-docker
$SCRIPTS/saws
$SCRIPTS/scrape-terraform-resource

* automate aws
** TODO enable iam billing
I don't know how to do this with the CLI yet.

#+BEGIN_SRC sh -n :sps bash :async :results none
  egr aws cli enable iam billing
#+END_SRC

https://console.aws.amazon.com/billing/home?#/account

** TODO Make some aws tablists
#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  aws iam list-users
#+END_SRC

#+RESULTS:
#+begin_src bash
{
    "Users": []
}
#+end_src

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  aws iam create-user --user-name Shane
#+END_SRC

** TODO Key management
*** List keys -- make a tablist
#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  aws ec2 describe-key-pairs
#+END_SRC

Your private key isn't stored in AWS and can
be retrieved only when it's created. You can't
recover it later. Instead, if you lose the
private key, you must create a new key pair.

When I create the key pair, I should also
download and save the json.

#+RESULTS:
#+begin_src bash
{
    "KeyPairs": [
        {
            "KeyPairId": "key-0b6e4e12d64f459bf",
            "KeyFingerprint": "b3:f0:48:25:b6:94:d1:b0:8c:42:be:ba:25:02:32:b3:a4:29:49:14",
            "KeyName": "AdminKey",
            "Tags": []
        }
    ]
}
#+end_src

*** Create key
#+BEGIN_SRC sh -n :sps bash :async :results none
  aws ec2 create-key-pair --key-name AdminKey
#+END_SRC

**** Download key to ssh file when it's created
#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  jq -r .KeyMaterial > ~/.ssh/ids/AdminKey.pem
#+END_SRC

* copy password
$NOTES/personal/passwords/google-gmail-aws2021.txt

* TODO Make a list of pages I have automated the CLI for
** Create admin user, admin group and admin policy
https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html

* Install
https://github.com/aome510/hackernews-TUI
** lmgrep
https://github.com/dainiusjocas/lucene-grep

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  echo "Lucene is awesome" | docker run --entrypoint "" --rm --name dainiusjocas-lucene-grep-e9cfdfb9-1-0-11f9f2c4-19dc-4a94-a13b-9bc3319e32ce -v /home/shane/source/git:/media/mygit -i dainiusjocas-lucene-grep-e9cfdfb9:1.0 ./lmgrep "Lucene"
#+END_SRC

#+RESULTS:
#+begin_src bash
[0;35m*STDIN*[0m:[0;32m1[0m:[1;31mLucene[0m is awesome
#+end_src

*** Read this
https://www.jocas.lt/blog/post/intro-to-lucene-grep/

* TODO Make some kind of fuzzyfinder for API endpoints
** Fuzzy select the name of an API
** Fuzzy select from the endpoints

* Get this
https://youtu.be/oZCPnnDlBvI?t=1152

* TODO Find a universal API fuzzy finder and explorer

* Find a way to fuzzy search the AWS API

* List all API endpoints
[[egr:aws api list all endpoints]]
[[egr:github api list all endpoints]]
[[egr:gitlab api list all endpoints]]
[[egr:terraform api list all endpoints]]
[[egr:docker api list all endpoints]]

** Fuzzy search endpoits
I need custom fuzzy finders.
I've been working on that in emacs, which is good.

* TODO Automate the aws cli a bit more
- filter-cmd-buttonize
- =aws-instances=

* Set up tools
** Set up =aws-shell=
https://aws.amazon.com/blogs/developer/super-charge-your-aws-command-line-experience-with-aws-shell/

** Set up =saws=
#+BEGIN_SRC sh -n :sps bash :async :results none
  x -sh saws -z "saws>" -s "aws " -i
#+END_SRC

** =aws-fuzzy-finder=
https://github.com/pmazurek/aws-fuzzy-finder

#+BEGIN_SRC sh -n :sps bash :async :results none
  py -36 i aws-fuzzy-finder
#+END_SRC

This is just for finding instances and sshing into them.

But it would be more useful to automate/extend emacs' =aws-instances=.

#+BEGIN_SRC sh -n :sps bash :async :results none
  mkw aws-fuzzy
#+END_SRC

* copy across
e:$SCRIPTS/docker-get-build-cmd

* docker wrapper for lmgrep
$SCRIPTS/lmgrep

* TODO Set up aws user account
https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  oci aws iam create-user --user-name Administrator
  # Enable console login
  oci aws iam create-login-profile --user-name Administrator --password "$(pwgen 30 1 >> $NOTES/personal/passwords/aws-administrator.txt)"
  # Enable programmatic access
  oci aws iam create-access-key --user-name Administrator >> $NOTES/personal/passwords/aws-administrator-programmatic.json
#+END_SRC

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  oci aws iam create-user --user-name Administrator
#+END_SRC

#+RESULTS:
#+begin_src bash
{
    "User": {
        "Path": "/",
        "UserName": "Administrator",
        "UserId": "AIDAR55HCH7KNSLMHLBLO",
        "Arn": "arn:aws:iam::132957487060:user/Administrator",
        "CreateDate": "2021-04-26T00:07:09Z"
    }
}
#+end_src

# fuzzify
# aws iam list-policies

#+BEGIN_SRC text -n :async :results verbatim code
  AdministratorAccess
#+END_SRC

** Select the =AdministratorAccess= policy and add to =Administrator=
Use emacs and tablist for this.

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  oci aws iam list-policies | jq -r ".Policies[] | [ .PolicyName, .Arn ] | @csv"
#+END_SRC

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  "AdministratorAccess","arn:aws:iam::aws:policy/AdministratorAccess"
#+END_SRC

** Try out this one
http://harelba.github.io/q/

Or use awk in the interim.

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  "AdministratorAccess","arn:aws:iam::aws:policy/AdministratorAccess"
#+END_SRC

#+BEGIN_SRC text -n :async :results verbatim code
  "arn:aws:iam::aws:policy/AdministratorAccess"
#+END_SRC

#+BEGIN_SRC bash -n :i bash :async :results verbatim code
  oci aws iam attach-user-policy --user-name Administrator --policy-arn "arn:aws:iam::aws:policy/AdministratorAccess"
#+END_SRC

#+RESULTS:
#+begin_src bash
#+end_src

#+BEGIN_SRC plantuml -n :f "plantuml -svg" :async :results raw :file aws-example.svg
  !include <awslib/AWSCommon>
  !include <awslib/AWSSimplified.puml>
  !include <awslib/Compute/all.puml>
  !include <awslib/mobile/all.puml>
  !include <awslib/general/all.puml>
  !include <awslib/GroupIcons/all.puml>
  
   skinparam linetype polyline
  ' skinparam linetype ortho
  
  package "AWS Cloud" {
  EC2(Smadex, "Smadex Service", " ")
  }
  
  Users(Users, "Users", " ")
  TraditionalServer(AdExchange, "Ad Exchange", " ")
  Mobile(Mobile, "Publisher app or web", " ")
  
  Users -down-> Mobile: 1. Visits
  Mobile -right-> AdExchange: 2. Start auction
  AdExchange -right-> Smadex: 3. Bid request / response
  Smadex -left-> Mobile: 4. Show Ad
  Users -right-> Smadex: 5. Impression / click / install / event {request id}
#+END_SRC

#+RESULTS:
[[file:aws-example.svg]]

** Automate building the aws diagram
$SCRIPTS/plantuml-list-sprites
https://github.com/plantuml/plantuml-stdlib/tree/master/awslib

#+BEGIN_SRC plantuml -n :f "plantuml -svg" :async :results raw :file aws-sprites.svg
  !include <awslib/AWSCommon>
  !include <awslib/Compute/all.puml>
  !include <awslib/mobile/all.puml>
  !include <awslib/general/all.puml>
  
  listsprites
#+END_SRC

#+RESULTS:
[[file:aws-sprites.svg]]

#+BEGIN_SRC plantuml -n :f "plantuml -svg" :async :results raw :file terraformclojure.svg
  !include <awslib/AWSCommon>
  !include <awslib/AWSSimplified.puml>
  !include <awslib/Compute/all.puml>
  !include <awslib/mobile/all.puml>
  !include <awslib/general/all.puml>
  !include <awslib/GroupIcons/all.puml>

   skinparam linetype polyline
  ' skinparam linetype ortho

  ' package "AWS Cloud" {
  ' EC2(Smadex, "Smadex Service", " ")
  ' }

  EC2(ALBLoadBalancer, "ALB (Application Load Balancer)", " ")
  EC2(NLBLoadBalancer, "NLB (Network Load Balancer)", " ")
  EC2AutoScaling(AutoscalingGroup, "Autoscaling Group", " ")
  EC2InstancewithCloudWatch(InstanceCW, "Instance with CloudWatch", " ")
  General(App1, "App", " ")
  General(App2, "App", " ")
  GenericDatabase(DB, "Database", " ")

  ALBLoadBalancer -down-> InstanceCW
  NLBLoadBalancer -down-> InstanceCW
  AutoscalingGroup -right-> InstanceCW
  InstanceCW -down-> App1: Port 3000
  InstanceCW -down-> App2: Port 3000
  InstanceCW -down-> DB: Port 5432
#+END_SRC

#+RESULTS:
[[file:terraformclojure.svg]]

Set up two ECS tasks called film_ratings_app and film_ratings_db.

** Commentary
The app instances need to communicate with the
DB instance via port 5432. In order to do
this, they need to route their requests via a
network load balancer ( film-ratings-nw-load-
balancer). So when we set up the
film_ratings_app task, we need to pass the
containers the network load balancer's DNS
name in order for the application within the
container to use it as the DB_HOST to
communicate with the database.