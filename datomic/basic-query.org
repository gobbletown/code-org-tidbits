* Basic query
#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  [:find ?name
   :where
   [11 :user/name ?name]]
#+END_SRC

- name is bound

Order doesn't matter.

=where= is a set of clauses.

Always return sets of tuples.

Datalog is declarative and logic oriented.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  [:find ?id
   :where
   [?id :user/name "tonsky"]]
#+END_SRC

This will find the id.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  [:find ?name
   :where
   [_ :user/name ?name]]
#+END_SRC

Find all usernames and return the values.

#+BEGIN_SRC text -n :async :results verbatim code
  ∈{["richhickey"] ["tonsky"] ["pithyless"]}
#+END_SRC

#+BEGIN_SRC text -n :async :results verbatim code
  ∈
      ∈	(-	2208	8712	ELEMENT OF
  
      A returned set from a query.
#+END_SRC

Sets return duplicates.

By default datomic queries return a set of tuples.
If you use the elipses then it will return a vector.

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  [:find [?name ...]
   :where
   [_ :user/name ?name]]
#+END_SRC

#+BEGIN_SRC text -n :async :results verbatim code
  "tonsky"
#+END_SRC

It matched all 3 and return a set, so it
returns one value such that it's true.

** multiple bindings
If you want to return multiple things:

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  [:find ?id ?name
   :where
   [?id :user/name ?name]]
#+END_SRC

#+BEGIN_SRC clojure -n :i clj :async :results verbatim code
  ∈{[11 "richhickey"] [22 "tonsky"] [33 "pithyless"]}
#+END_SRC

Now we have a tuple of 2 values.

** Add an email address
Now lets complicate the business domain.